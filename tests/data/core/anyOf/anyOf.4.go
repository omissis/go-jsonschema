// Code generated by github.com/atombender/go-jsonschema, DO NOT EDIT.

package test

import "encoding/json"
import "errors"
import "fmt"
import yaml "gopkg.in/yaml.v3"
import "reflect"

type AnyOf4 []AnyOf4Elem

type AnyOf4Elem struct {
	// When consuming a CDEvent, you are consuming a parent event. So, when looking at
	// the 'from' key, this is the parent's parent.
	From EmbeddedlinkendFrom `json:"from" yaml:"from" mapstructure:"from"`

	// LinkKind corresponds to the JSON schema field "linkKind".
	LinkKind string `json:"linkKind" yaml:"linkKind" mapstructure:"linkKind"`

	// LinkType corresponds to the JSON schema field "linkType".
	LinkType EmbeddedlinkendLinkType `json:"linkType" yaml:"linkType" mapstructure:"linkType"`

	// Tags corresponds to the JSON schema field "tags".
	Tags map[string]interface{} `json:"tags,omitempty" yaml:"tags,omitempty" mapstructure:"tags,omitempty"`

	// Target corresponds to the JSON schema field "target".
	Target EmbeddedlinkrelationTarget `json:"target" yaml:"target" mapstructure:"target"`
}

// UnmarshalYAML implements yaml.Unmarshaler.
func (j *AnyOf4Elem) UnmarshalYAML(value *yaml.Node) error {
	var raw map[string]interface{}
	if err := value.Decode(&raw); err != nil {
		return err
	}
	var anyOf4Elem_0 AnyOf4Elem_0
	var anyOf4Elem_1 AnyOf4Elem_1
	var anyOf4Elem_2 AnyOf4Elem_2
	var errs []error
	if err := anyOf4Elem_0.UnmarshalYAML(value); err != nil {
		errs = append(errs, err)
	}
	if err := anyOf4Elem_1.UnmarshalYAML(value); err != nil {
		errs = append(errs, err)
	}
	if err := anyOf4Elem_2.UnmarshalYAML(value); err != nil {
		errs = append(errs, err)
	}
	if len(errs) == 3 {
		return fmt.Errorf("all validators failed: %s", errors.Join(errs...))
	}
	type Plain AnyOf4Elem
	var plain Plain
	if err := value.Decode(&plain); err != nil {
		return err
	}
	*j = AnyOf4Elem(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *AnyOf4Elem) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	var anyOf4Elem_0 AnyOf4Elem_0
	var anyOf4Elem_1 AnyOf4Elem_1
	var anyOf4Elem_2 AnyOf4Elem_2
	var errs []error
	if err := anyOf4Elem_0.UnmarshalJSON(value); err != nil {
		errs = append(errs, err)
	}
	if err := anyOf4Elem_1.UnmarshalJSON(value); err != nil {
		errs = append(errs, err)
	}
	if err := anyOf4Elem_2.UnmarshalJSON(value); err != nil {
		errs = append(errs, err)
	}
	if len(errs) == 3 {
		return fmt.Errorf("all validators failed: %s", errors.Join(errs...))
	}
	type Plain AnyOf4Elem
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = AnyOf4Elem(plain)
	return nil
}

type Embeddedlinkend struct {
	// When consuming a CDEvent, you are consuming a parent event. So, when looking at
	// the 'from' key, this is the parent's parent.
	From *EmbeddedlinkendFrom `json:"from,omitempty" yaml:"from,omitempty" mapstructure:"from,omitempty"`

	// LinkType corresponds to the JSON schema field "linkType".
	LinkType EmbeddedlinkendLinkType `json:"linkType" yaml:"linkType" mapstructure:"linkType"`

	// Tags corresponds to the JSON schema field "tags".
	Tags map[string]interface{} `json:"tags,omitempty" yaml:"tags,omitempty" mapstructure:"tags,omitempty"`
}

// When consuming a CDEvent, you are consuming a parent event. So, when looking at
// the 'from' key, this is the parent's parent.
type EmbeddedlinkendFrom struct {
	// ContextId corresponds to the JSON schema field "contextId".
	ContextId string `json:"contextId" yaml:"contextId" mapstructure:"contextId"`
}

// UnmarshalYAML implements yaml.Unmarshaler.
func (j *EmbeddedlinkendFrom) UnmarshalYAML(value *yaml.Node) error {
	var raw map[string]interface{}
	if err := value.Decode(&raw); err != nil {
		return err
	}
	if _, ok := raw["contextId"]; raw != nil && !ok {
		return fmt.Errorf("field contextId in EmbeddedlinkendFrom: required")
	}
	type Plain EmbeddedlinkendFrom
	var plain Plain
	if err := value.Decode(&plain); err != nil {
		return err
	}
	if len(plain.ContextId) < 1 {
		return fmt.Errorf("field %s length: must be >= %d", "contextId", 1)
	}
	*j = EmbeddedlinkendFrom(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *EmbeddedlinkendFrom) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["contextId"]; raw != nil && !ok {
		return fmt.Errorf("field contextId in EmbeddedlinkendFrom: required")
	}
	type Plain EmbeddedlinkendFrom
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	if len(plain.ContextId) < 1 {
		return fmt.Errorf("field %s length: must be >= %d", "contextId", 1)
	}
	*j = EmbeddedlinkendFrom(plain)
	return nil
}

type EmbeddedlinkendLinkType string

const EmbeddedlinkendLinkTypeEND EmbeddedlinkendLinkType = "END"

var enumValues_EmbeddedlinkendLinkType = []interface{}{
	"END",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *EmbeddedlinkendLinkType) UnmarshalJSON(value []byte) error {
	var v string
	if err := json.Unmarshal(value, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_EmbeddedlinkendLinkType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_EmbeddedlinkendLinkType, v)
	}
	*j = EmbeddedlinkendLinkType(v)
	return nil
}

// UnmarshalYAML implements yaml.Unmarshaler.
func (j *EmbeddedlinkendLinkType) UnmarshalYAML(value *yaml.Node) error {
	var v string
	if err := value.Decode(&v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_EmbeddedlinkendLinkType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_EmbeddedlinkendLinkType, v)
	}
	*j = EmbeddedlinkendLinkType(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *Embeddedlinkend) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["linkType"]; raw != nil && !ok {
		return fmt.Errorf("field linkType in Embeddedlinkend: required")
	}
	type Plain Embeddedlinkend
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = Embeddedlinkend(plain)
	return nil
}

// UnmarshalYAML implements yaml.Unmarshaler.
func (j *Embeddedlinkend) UnmarshalYAML(value *yaml.Node) error {
	var raw map[string]interface{}
	if err := value.Decode(&raw); err != nil {
		return err
	}
	if _, ok := raw["linkType"]; raw != nil && !ok {
		return fmt.Errorf("field linkType in Embeddedlinkend: required")
	}
	type Plain Embeddedlinkend
	var plain Plain
	if err := value.Decode(&plain); err != nil {
		return err
	}
	*j = Embeddedlinkend(plain)
	return nil
}

type Embeddedlinkpath struct {
	// When consuming a CDEvent, you are consuming a parent event. So, when looking at
	// the 'from' key, this is the parent's parent.
	From EmbeddedlinkpathFrom `json:"from" yaml:"from" mapstructure:"from"`

	// LinkType corresponds to the JSON schema field "linkType".
	LinkType EmbeddedlinkpathLinkType `json:"linkType" yaml:"linkType" mapstructure:"linkType"`

	// Tags corresponds to the JSON schema field "tags".
	Tags map[string]interface{} `json:"tags,omitempty" yaml:"tags,omitempty" mapstructure:"tags,omitempty"`
}

// When consuming a CDEvent, you are consuming a parent event. So, when looking at
// the 'from' key, this is the parent's parent.
type EmbeddedlinkpathFrom struct {
	// ContextId corresponds to the JSON schema field "contextId".
	ContextId string `json:"contextId" yaml:"contextId" mapstructure:"contextId"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *EmbeddedlinkpathFrom) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["contextId"]; raw != nil && !ok {
		return fmt.Errorf("field contextId in EmbeddedlinkpathFrom: required")
	}
	type Plain EmbeddedlinkpathFrom
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	if len(plain.ContextId) < 1 {
		return fmt.Errorf("field %s length: must be >= %d", "contextId", 1)
	}
	*j = EmbeddedlinkpathFrom(plain)
	return nil
}

// UnmarshalYAML implements yaml.Unmarshaler.
func (j *EmbeddedlinkpathFrom) UnmarshalYAML(value *yaml.Node) error {
	var raw map[string]interface{}
	if err := value.Decode(&raw); err != nil {
		return err
	}
	if _, ok := raw["contextId"]; raw != nil && !ok {
		return fmt.Errorf("field contextId in EmbeddedlinkpathFrom: required")
	}
	type Plain EmbeddedlinkpathFrom
	var plain Plain
	if err := value.Decode(&plain); err != nil {
		return err
	}
	if len(plain.ContextId) < 1 {
		return fmt.Errorf("field %s length: must be >= %d", "contextId", 1)
	}
	*j = EmbeddedlinkpathFrom(plain)
	return nil
}

type EmbeddedlinkpathLinkType string

const EmbeddedlinkpathLinkTypePATH EmbeddedlinkpathLinkType = "PATH"

var enumValues_EmbeddedlinkpathLinkType = []interface{}{
	"PATH",
}

// UnmarshalYAML implements yaml.Unmarshaler.
func (j *EmbeddedlinkpathLinkType) UnmarshalYAML(value *yaml.Node) error {
	var v string
	if err := value.Decode(&v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_EmbeddedlinkpathLinkType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_EmbeddedlinkpathLinkType, v)
	}
	*j = EmbeddedlinkpathLinkType(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *EmbeddedlinkpathLinkType) UnmarshalJSON(value []byte) error {
	var v string
	if err := json.Unmarshal(value, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_EmbeddedlinkpathLinkType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_EmbeddedlinkpathLinkType, v)
	}
	*j = EmbeddedlinkpathLinkType(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *Embeddedlinkpath) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["from"]; raw != nil && !ok {
		return fmt.Errorf("field from in Embeddedlinkpath: required")
	}
	if _, ok := raw["linkType"]; raw != nil && !ok {
		return fmt.Errorf("field linkType in Embeddedlinkpath: required")
	}
	type Plain Embeddedlinkpath
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = Embeddedlinkpath(plain)
	return nil
}

// UnmarshalYAML implements yaml.Unmarshaler.
func (j *Embeddedlinkpath) UnmarshalYAML(value *yaml.Node) error {
	var raw map[string]interface{}
	if err := value.Decode(&raw); err != nil {
		return err
	}
	if _, ok := raw["from"]; raw != nil && !ok {
		return fmt.Errorf("field from in Embeddedlinkpath: required")
	}
	if _, ok := raw["linkType"]; raw != nil && !ok {
		return fmt.Errorf("field linkType in Embeddedlinkpath: required")
	}
	type Plain Embeddedlinkpath
	var plain Plain
	if err := value.Decode(&plain); err != nil {
		return err
	}
	*j = Embeddedlinkpath(plain)
	return nil
}

type Embeddedlinkrelation struct {
	// LinkKind corresponds to the JSON schema field "linkKind".
	LinkKind string `json:"linkKind" yaml:"linkKind" mapstructure:"linkKind"`

	// LinkType corresponds to the JSON schema field "linkType".
	LinkType EmbeddedlinkrelationLinkType `json:"linkType" yaml:"linkType" mapstructure:"linkType"`

	// Tags corresponds to the JSON schema field "tags".
	Tags map[string]interface{} `json:"tags,omitempty" yaml:"tags,omitempty" mapstructure:"tags,omitempty"`

	// Target corresponds to the JSON schema field "target".
	Target EmbeddedlinkrelationTarget `json:"target" yaml:"target" mapstructure:"target"`
}

type EmbeddedlinkrelationLinkType string

const EmbeddedlinkrelationLinkTypeRELATION EmbeddedlinkrelationLinkType = "RELATION"

var enumValues_EmbeddedlinkrelationLinkType = []interface{}{
	"RELATION",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *EmbeddedlinkrelationLinkType) UnmarshalJSON(value []byte) error {
	var v string
	if err := json.Unmarshal(value, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_EmbeddedlinkrelationLinkType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_EmbeddedlinkrelationLinkType, v)
	}
	*j = EmbeddedlinkrelationLinkType(v)
	return nil
}

// UnmarshalYAML implements yaml.Unmarshaler.
func (j *EmbeddedlinkrelationLinkType) UnmarshalYAML(value *yaml.Node) error {
	var v string
	if err := value.Decode(&v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_EmbeddedlinkrelationLinkType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_EmbeddedlinkrelationLinkType, v)
	}
	*j = EmbeddedlinkrelationLinkType(v)
	return nil
}

type EmbeddedlinkrelationTarget struct {
	// ContextId corresponds to the JSON schema field "contextId".
	ContextId *string `json:"contextId,omitempty" yaml:"contextId,omitempty" mapstructure:"contextId,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *EmbeddedlinkrelationTarget) UnmarshalJSON(value []byte) error {
	type Plain EmbeddedlinkrelationTarget
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	if plain.ContextId != nil && len(*plain.ContextId) < 1 {
		return fmt.Errorf("field %s length: must be >= %d", "contextId", 1)
	}
	*j = EmbeddedlinkrelationTarget(plain)
	return nil
}

// UnmarshalYAML implements yaml.Unmarshaler.
func (j *EmbeddedlinkrelationTarget) UnmarshalYAML(value *yaml.Node) error {
	type Plain EmbeddedlinkrelationTarget
	var plain Plain
	if err := value.Decode(&plain); err != nil {
		return err
	}
	if plain.ContextId != nil && len(*plain.ContextId) < 1 {
		return fmt.Errorf("field %s length: must be >= %d", "contextId", 1)
	}
	*j = EmbeddedlinkrelationTarget(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *Embeddedlinkrelation) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["linkKind"]; raw != nil && !ok {
		return fmt.Errorf("field linkKind in Embeddedlinkrelation: required")
	}
	if _, ok := raw["linkType"]; raw != nil && !ok {
		return fmt.Errorf("field linkType in Embeddedlinkrelation: required")
	}
	if _, ok := raw["target"]; raw != nil && !ok {
		return fmt.Errorf("field target in Embeddedlinkrelation: required")
	}
	type Plain Embeddedlinkrelation
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	if len(plain.LinkKind) < 1 {
		return fmt.Errorf("field %s length: must be >= %d", "linkKind", 1)
	}
	*j = Embeddedlinkrelation(plain)
	return nil
}

type AnyOf4Elem_2 = Embeddedlinkrelation
type AnyOf4Elem_1 = Embeddedlinkpath
type AnyOf4Elem_0 = Embeddedlinkend

// UnmarshalYAML implements yaml.Unmarshaler.
func (j *Embeddedlinkrelation) UnmarshalYAML(value *yaml.Node) error {
	var raw map[string]interface{}
	if err := value.Decode(&raw); err != nil {
		return err
	}
	if _, ok := raw["linkKind"]; raw != nil && !ok {
		return fmt.Errorf("field linkKind in Embeddedlinkrelation: required")
	}
	if _, ok := raw["linkType"]; raw != nil && !ok {
		return fmt.Errorf("field linkType in Embeddedlinkrelation: required")
	}
	if _, ok := raw["target"]; raw != nil && !ok {
		return fmt.Errorf("field target in Embeddedlinkrelation: required")
	}
	type Plain Embeddedlinkrelation
	var plain Plain
	if err := value.Decode(&plain); err != nil {
		return err
	}
	if len(plain.LinkKind) < 1 {
		return fmt.Errorf("field %s length: must be >= %d", "linkKind", 1)
	}
	*j = Embeddedlinkrelation(plain)
	return nil
}
