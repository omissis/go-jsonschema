// Code generated by github.com/atombender/go-jsonschema, DO NOT EDIT.

package test

import "encoding/json"
import "fmt"
import yaml "gopkg.in/yaml.v3"
import "reflect"

type AllOf4 []AllOf4Elem

type AllOf4Elem struct {
	// When consuming a CDEvent, you are consuming a parent event. So, when looking at
	// the 'from' key, this is the parent's parent.
	From EmbeddedlinkendFrom `json:"from" yaml:"from" mapstructure:"from"`

	// LinkKind corresponds to the JSON schema field "linkKind".
	LinkKind string `json:"linkKind" yaml:"linkKind" mapstructure:"linkKind"`

	// LinkType corresponds to the JSON schema field "linkType".
	LinkType EmbeddedlinkendLinkType `json:"linkType" yaml:"linkType" mapstructure:"linkType"`

	// Tags corresponds to the JSON schema field "tags".
	Tags EmbeddedlinkendTags `json:"tags,omitempty" yaml:"tags,omitempty" mapstructure:"tags,omitempty"`

	// Target corresponds to the JSON schema field "target".
	Target EmbeddedlinkrelationTarget `json:"target" yaml:"target" mapstructure:"target"`
}

// UnmarshalYAML implements yaml.Unmarshaler.
func (j *AllOf4Elem) UnmarshalYAML(value *yaml.Node) error {
	var raw map[string]interface{}
	if err := value.Decode(&raw); err != nil {
		return err
	}
	if _, ok := raw["from"]; raw != nil && !ok {
		return fmt.Errorf("field from in AllOf4Elem: required")
	}
	if _, ok := raw["linkKind"]; raw != nil && !ok {
		return fmt.Errorf("field linkKind in AllOf4Elem: required")
	}
	if _, ok := raw["linkType"]; raw != nil && !ok {
		return fmt.Errorf("field linkType in AllOf4Elem: required")
	}
	if _, ok := raw["target"]; raw != nil && !ok {
		return fmt.Errorf("field target in AllOf4Elem: required")
	}
	type Plain AllOf4Elem
	var plain Plain
	if err := value.Decode(&plain); err != nil {
		return err
	}
	if len(plain.LinkKind) < 1 {
		return fmt.Errorf("field %s length: must be >= %d", "linkKind", 1)
	}
	*j = AllOf4Elem(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *AllOf4Elem) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["from"]; raw != nil && !ok {
		return fmt.Errorf("field from in AllOf4Elem: required")
	}
	if _, ok := raw["linkKind"]; raw != nil && !ok {
		return fmt.Errorf("field linkKind in AllOf4Elem: required")
	}
	if _, ok := raw["linkType"]; raw != nil && !ok {
		return fmt.Errorf("field linkType in AllOf4Elem: required")
	}
	if _, ok := raw["target"]; raw != nil && !ok {
		return fmt.Errorf("field target in AllOf4Elem: required")
	}
	type Plain AllOf4Elem
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	if len(plain.LinkKind) < 1 {
		return fmt.Errorf("field %s length: must be >= %d", "linkKind", 1)
	}
	*j = AllOf4Elem(plain)
	return nil
}

type Embeddedlinkend struct {
	// When consuming a CDEvent, you are consuming a parent event. So, when looking at
	// the 'from' key, this is the parent's parent.
	From *EmbeddedlinkendFrom `json:"from,omitempty" yaml:"from,omitempty" mapstructure:"from,omitempty"`

	// LinkType corresponds to the JSON schema field "linkType".
	LinkType EmbeddedlinkendLinkType `json:"linkType" yaml:"linkType" mapstructure:"linkType"`

	// Tags corresponds to the JSON schema field "tags".
	Tags EmbeddedlinkendTags `json:"tags,omitempty" yaml:"tags,omitempty" mapstructure:"tags,omitempty"`
}

// When consuming a CDEvent, you are consuming a parent event. So, when looking at
// the 'from' key, this is the parent's parent.
type EmbeddedlinkendFrom struct {
	// ContextId corresponds to the JSON schema field "contextId".
	ContextId string `json:"contextId" yaml:"contextId" mapstructure:"contextId"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *EmbeddedlinkendFrom) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["contextId"]; raw != nil && !ok {
		return fmt.Errorf("field contextId in EmbeddedlinkendFrom: required")
	}
	type Plain EmbeddedlinkendFrom
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	if len(plain.ContextId) < 1 {
		return fmt.Errorf("field %s length: must be >= %d", "contextId", 1)
	}
	*j = EmbeddedlinkendFrom(plain)
	return nil
}

// UnmarshalYAML implements yaml.Unmarshaler.
func (j *EmbeddedlinkendFrom) UnmarshalYAML(value *yaml.Node) error {
	var raw map[string]interface{}
	if err := value.Decode(&raw); err != nil {
		return err
	}
	if _, ok := raw["contextId"]; raw != nil && !ok {
		return fmt.Errorf("field contextId in EmbeddedlinkendFrom: required")
	}
	type Plain EmbeddedlinkendFrom
	var plain Plain
	if err := value.Decode(&plain); err != nil {
		return err
	}
	if len(plain.ContextId) < 1 {
		return fmt.Errorf("field %s length: must be >= %d", "contextId", 1)
	}
	*j = EmbeddedlinkendFrom(plain)
	return nil
}

type EmbeddedlinkendLinkType string

const EmbeddedlinkendLinkTypeEND EmbeddedlinkendLinkType = "END"

var enumValues_EmbeddedlinkendLinkType = []interface{}{
	"END",
}

// UnmarshalYAML implements yaml.Unmarshaler.
func (j *EmbeddedlinkendLinkType) UnmarshalYAML(value *yaml.Node) error {
	var v string
	if err := value.Decode(&v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_EmbeddedlinkendLinkType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_EmbeddedlinkendLinkType, v)
	}
	*j = EmbeddedlinkendLinkType(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *EmbeddedlinkendLinkType) UnmarshalJSON(value []byte) error {
	var v string
	if err := json.Unmarshal(value, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_EmbeddedlinkendLinkType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_EmbeddedlinkendLinkType, v)
	}
	*j = EmbeddedlinkendLinkType(v)
	return nil
}

type EmbeddedlinkendTags map[string]interface{}

// UnmarshalYAML implements yaml.Unmarshaler.
func (j *Embeddedlinkend) UnmarshalYAML(value *yaml.Node) error {
	var raw map[string]interface{}
	if err := value.Decode(&raw); err != nil {
		return err
	}
	if _, ok := raw["linkType"]; raw != nil && !ok {
		return fmt.Errorf("field linkType in Embeddedlinkend: required")
	}
	type Plain Embeddedlinkend
	var plain Plain
	if err := value.Decode(&plain); err != nil {
		return err
	}
	*j = Embeddedlinkend(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *Embeddedlinkend) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["linkType"]; raw != nil && !ok {
		return fmt.Errorf("field linkType in Embeddedlinkend: required")
	}
	type Plain Embeddedlinkend
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = Embeddedlinkend(plain)
	return nil
}

type Embeddedlinkpath struct {
	// When consuming a CDEvent, you are consuming a parent event. So, when looking at
	// the 'from' key, this is the parent's parent.
	From EmbeddedlinkpathFrom `json:"from" yaml:"from" mapstructure:"from"`

	// LinkType corresponds to the JSON schema field "linkType".
	LinkType EmbeddedlinkpathLinkType `json:"linkType" yaml:"linkType" mapstructure:"linkType"`

	// Tags corresponds to the JSON schema field "tags".
	Tags EmbeddedlinkpathTags `json:"tags,omitempty" yaml:"tags,omitempty" mapstructure:"tags,omitempty"`
}

// When consuming a CDEvent, you are consuming a parent event. So, when looking at
// the 'from' key, this is the parent's parent.
type EmbeddedlinkpathFrom struct {
	// ContextId corresponds to the JSON schema field "contextId".
	ContextId string `json:"contextId" yaml:"contextId" mapstructure:"contextId"`
}

// UnmarshalYAML implements yaml.Unmarshaler.
func (j *EmbeddedlinkpathFrom) UnmarshalYAML(value *yaml.Node) error {
	var raw map[string]interface{}
	if err := value.Decode(&raw); err != nil {
		return err
	}
	if _, ok := raw["contextId"]; raw != nil && !ok {
		return fmt.Errorf("field contextId in EmbeddedlinkpathFrom: required")
	}
	type Plain EmbeddedlinkpathFrom
	var plain Plain
	if err := value.Decode(&plain); err != nil {
		return err
	}
	if len(plain.ContextId) < 1 {
		return fmt.Errorf("field %s length: must be >= %d", "contextId", 1)
	}
	*j = EmbeddedlinkpathFrom(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *EmbeddedlinkpathFrom) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["contextId"]; raw != nil && !ok {
		return fmt.Errorf("field contextId in EmbeddedlinkpathFrom: required")
	}
	type Plain EmbeddedlinkpathFrom
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	if len(plain.ContextId) < 1 {
		return fmt.Errorf("field %s length: must be >= %d", "contextId", 1)
	}
	*j = EmbeddedlinkpathFrom(plain)
	return nil
}

type EmbeddedlinkpathLinkType string

const EmbeddedlinkpathLinkTypePATH EmbeddedlinkpathLinkType = "PATH"

var enumValues_EmbeddedlinkpathLinkType = []interface{}{
	"PATH",
}

// UnmarshalYAML implements yaml.Unmarshaler.
func (j *EmbeddedlinkpathLinkType) UnmarshalYAML(value *yaml.Node) error {
	var v string
	if err := value.Decode(&v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_EmbeddedlinkpathLinkType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_EmbeddedlinkpathLinkType, v)
	}
	*j = EmbeddedlinkpathLinkType(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *EmbeddedlinkpathLinkType) UnmarshalJSON(value []byte) error {
	var v string
	if err := json.Unmarshal(value, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_EmbeddedlinkpathLinkType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_EmbeddedlinkpathLinkType, v)
	}
	*j = EmbeddedlinkpathLinkType(v)
	return nil
}

type EmbeddedlinkpathTags map[string]interface{}

// UnmarshalJSON implements json.Unmarshaler.
func (j *Embeddedlinkpath) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["from"]; raw != nil && !ok {
		return fmt.Errorf("field from in Embeddedlinkpath: required")
	}
	if _, ok := raw["linkType"]; raw != nil && !ok {
		return fmt.Errorf("field linkType in Embeddedlinkpath: required")
	}
	type Plain Embeddedlinkpath
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = Embeddedlinkpath(plain)
	return nil
}

// UnmarshalYAML implements yaml.Unmarshaler.
func (j *Embeddedlinkpath) UnmarshalYAML(value *yaml.Node) error {
	var raw map[string]interface{}
	if err := value.Decode(&raw); err != nil {
		return err
	}
	if _, ok := raw["from"]; raw != nil && !ok {
		return fmt.Errorf("field from in Embeddedlinkpath: required")
	}
	if _, ok := raw["linkType"]; raw != nil && !ok {
		return fmt.Errorf("field linkType in Embeddedlinkpath: required")
	}
	type Plain Embeddedlinkpath
	var plain Plain
	if err := value.Decode(&plain); err != nil {
		return err
	}
	*j = Embeddedlinkpath(plain)
	return nil
}

type Embeddedlinkrelation struct {
	// LinkKind corresponds to the JSON schema field "linkKind".
	LinkKind string `json:"linkKind" yaml:"linkKind" mapstructure:"linkKind"`

	// LinkType corresponds to the JSON schema field "linkType".
	LinkType EmbeddedlinkrelationLinkType `json:"linkType" yaml:"linkType" mapstructure:"linkType"`

	// Tags corresponds to the JSON schema field "tags".
	Tags EmbeddedlinkrelationTags `json:"tags,omitempty" yaml:"tags,omitempty" mapstructure:"tags,omitempty"`

	// Target corresponds to the JSON schema field "target".
	Target EmbeddedlinkrelationTarget `json:"target" yaml:"target" mapstructure:"target"`
}

type EmbeddedlinkrelationLinkType string

const EmbeddedlinkrelationLinkTypeRELATION EmbeddedlinkrelationLinkType = "RELATION"

var enumValues_EmbeddedlinkrelationLinkType = []interface{}{
	"RELATION",
}

// UnmarshalYAML implements yaml.Unmarshaler.
func (j *EmbeddedlinkrelationLinkType) UnmarshalYAML(value *yaml.Node) error {
	var v string
	if err := value.Decode(&v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_EmbeddedlinkrelationLinkType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_EmbeddedlinkrelationLinkType, v)
	}
	*j = EmbeddedlinkrelationLinkType(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *EmbeddedlinkrelationLinkType) UnmarshalJSON(value []byte) error {
	var v string
	if err := json.Unmarshal(value, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_EmbeddedlinkrelationLinkType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_EmbeddedlinkrelationLinkType, v)
	}
	*j = EmbeddedlinkrelationLinkType(v)
	return nil
}

type EmbeddedlinkrelationTags map[string]interface{}

type EmbeddedlinkrelationTarget struct {
	// ContextId corresponds to the JSON schema field "contextId".
	ContextId *string `json:"contextId,omitempty" yaml:"contextId,omitempty" mapstructure:"contextId,omitempty"`
}

// UnmarshalYAML implements yaml.Unmarshaler.
func (j *EmbeddedlinkrelationTarget) UnmarshalYAML(value *yaml.Node) error {
	type Plain EmbeddedlinkrelationTarget
	var plain Plain
	if err := value.Decode(&plain); err != nil {
		return err
	}
	if plain.ContextId != nil && len(*plain.ContextId) < 1 {
		return fmt.Errorf("field %s length: must be >= %d", "contextId", 1)
	}
	*j = EmbeddedlinkrelationTarget(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *EmbeddedlinkrelationTarget) UnmarshalJSON(value []byte) error {
	type Plain EmbeddedlinkrelationTarget
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	if plain.ContextId != nil && len(*plain.ContextId) < 1 {
		return fmt.Errorf("field %s length: must be >= %d", "contextId", 1)
	}
	*j = EmbeddedlinkrelationTarget(plain)
	return nil
}

// UnmarshalYAML implements yaml.Unmarshaler.
func (j *Embeddedlinkrelation) UnmarshalYAML(value *yaml.Node) error {
	var raw map[string]interface{}
	if err := value.Decode(&raw); err != nil {
		return err
	}
	if _, ok := raw["linkKind"]; raw != nil && !ok {
		return fmt.Errorf("field linkKind in Embeddedlinkrelation: required")
	}
	if _, ok := raw["linkType"]; raw != nil && !ok {
		return fmt.Errorf("field linkType in Embeddedlinkrelation: required")
	}
	if _, ok := raw["target"]; raw != nil && !ok {
		return fmt.Errorf("field target in Embeddedlinkrelation: required")
	}
	type Plain Embeddedlinkrelation
	var plain Plain
	if err := value.Decode(&plain); err != nil {
		return err
	}
	if len(plain.LinkKind) < 1 {
		return fmt.Errorf("field %s length: must be >= %d", "linkKind", 1)
	}
	*j = Embeddedlinkrelation(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *Embeddedlinkrelation) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["linkKind"]; raw != nil && !ok {
		return fmt.Errorf("field linkKind in Embeddedlinkrelation: required")
	}
	if _, ok := raw["linkType"]; raw != nil && !ok {
		return fmt.Errorf("field linkType in Embeddedlinkrelation: required")
	}
	if _, ok := raw["target"]; raw != nil && !ok {
		return fmt.Errorf("field target in Embeddedlinkrelation: required")
	}
	type Plain Embeddedlinkrelation
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	if len(plain.LinkKind) < 1 {
		return fmt.Errorf("field %s length: must be >= %d", "linkKind", 1)
	}
	*j = Embeddedlinkrelation(plain)
	return nil
}
