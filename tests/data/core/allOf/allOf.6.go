// Code generated by github.com/atombender/go-jsonschema, DO NOT EDIT.

package test

import "encoding/json"
import "fmt"
import yaml "gopkg.in/yaml.v3"
import "reflect"
import "time"

type AllOf6 struct {
	// AdditionalData corresponds to the JSON schema field "additionalData".
	AdditionalData []string `json:"additionalData,omitempty" yaml:"additionalData,omitempty" mapstructure:"additionalData,omitempty"`

	// When consuming a CDEvent, you are consuming a parent event. So, when looking at
	// the 'from' key, this is the parent's parent.
	From LinkendFrom `json:"from" yaml:"from" mapstructure:"from"`

	// LinkKind corresponds to the JSON schema field "linkKind".
	LinkKind string `json:"linkKind" yaml:"linkKind" mapstructure:"linkKind"`

	// LinkType corresponds to the JSON schema field "linkType".
	LinkType LinkendLinkType `json:"linkType" yaml:"linkType" mapstructure:"linkType"`

	// Metadata corresponds to the JSON schema field "metadata".
	Metadata *AllOf6Metadata `json:"metadata,omitempty" yaml:"metadata,omitempty" mapstructure:"metadata,omitempty"`

	// Tags corresponds to the JSON schema field "tags".
	Tags LinkendTags `json:"tags,omitempty" yaml:"tags,omitempty" mapstructure:"tags,omitempty"`

	// Target corresponds to the JSON schema field "target".
	Target LinkrelationTarget `json:"target" yaml:"target" mapstructure:"target"`
}

type AllOf6Metadata struct {
	// Timestamp corresponds to the JSON schema field "timestamp".
	Timestamp *time.Time `json:"timestamp,omitempty" yaml:"timestamp,omitempty" mapstructure:"timestamp,omitempty"`

	// Version corresponds to the JSON schema field "version".
	Version *string `json:"version,omitempty" yaml:"version,omitempty" mapstructure:"version,omitempty"`
}

// UnmarshalYAML implements yaml.Unmarshaler.
func (j *AllOf6) UnmarshalYAML(value *yaml.Node) error {
	var raw map[string]interface{}
	if err := value.Decode(&raw); err != nil {
		return err
	}
	if _, ok := raw["from"]; raw != nil && !ok {
		return fmt.Errorf("field from in AllOf6: required")
	}
	if _, ok := raw["linkKind"]; raw != nil && !ok {
		return fmt.Errorf("field linkKind in AllOf6: required")
	}
	if _, ok := raw["linkType"]; raw != nil && !ok {
		return fmt.Errorf("field linkType in AllOf6: required")
	}
	if _, ok := raw["target"]; raw != nil && !ok {
		return fmt.Errorf("field target in AllOf6: required")
	}
	type Plain AllOf6
	var plain Plain
	if err := value.Decode(&plain); err != nil {
		return err
	}
	if len(plain.LinkKind) < 1 {
		return fmt.Errorf("field %s length: must be >= %d", "linkKind", 1)
	}
	*j = AllOf6(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *AllOf6) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["from"]; raw != nil && !ok {
		return fmt.Errorf("field from in AllOf6: required")
	}
	if _, ok := raw["linkKind"]; raw != nil && !ok {
		return fmt.Errorf("field linkKind in AllOf6: required")
	}
	if _, ok := raw["linkType"]; raw != nil && !ok {
		return fmt.Errorf("field linkType in AllOf6: required")
	}
	if _, ok := raw["target"]; raw != nil && !ok {
		return fmt.Errorf("field target in AllOf6: required")
	}
	type Plain AllOf6
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	if len(plain.LinkKind) < 1 {
		return fmt.Errorf("field %s length: must be >= %d", "linkKind", 1)
	}
	*j = AllOf6(plain)
	return nil
}

type Linkend struct {
	// When consuming a CDEvent, you are consuming a parent event. So, when looking at
	// the 'from' key, this is the parent's parent.
	From *LinkendFrom `json:"from,omitempty" yaml:"from,omitempty" mapstructure:"from,omitempty"`

	// LinkType corresponds to the JSON schema field "linkType".
	LinkType LinkendLinkType `json:"linkType" yaml:"linkType" mapstructure:"linkType"`

	// Tags corresponds to the JSON schema field "tags".
	Tags LinkendTags `json:"tags,omitempty" yaml:"tags,omitempty" mapstructure:"tags,omitempty"`
}

// When consuming a CDEvent, you are consuming a parent event. So, when looking at
// the 'from' key, this is the parent's parent.
type LinkendFrom struct {
	// ContextId corresponds to the JSON schema field "contextId".
	ContextId string `json:"contextId" yaml:"contextId" mapstructure:"contextId"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *LinkendFrom) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["contextId"]; raw != nil && !ok {
		return fmt.Errorf("field contextId in LinkendFrom: required")
	}
	type Plain LinkendFrom
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	if len(plain.ContextId) < 1 {
		return fmt.Errorf("field %s length: must be >= %d", "contextId", 1)
	}
	*j = LinkendFrom(plain)
	return nil
}

// UnmarshalYAML implements yaml.Unmarshaler.
func (j *LinkendFrom) UnmarshalYAML(value *yaml.Node) error {
	var raw map[string]interface{}
	if err := value.Decode(&raw); err != nil {
		return err
	}
	if _, ok := raw["contextId"]; raw != nil && !ok {
		return fmt.Errorf("field contextId in LinkendFrom: required")
	}
	type Plain LinkendFrom
	var plain Plain
	if err := value.Decode(&plain); err != nil {
		return err
	}
	if len(plain.ContextId) < 1 {
		return fmt.Errorf("field %s length: must be >= %d", "contextId", 1)
	}
	*j = LinkendFrom(plain)
	return nil
}

type LinkendLinkType string

const LinkendLinkTypeEND LinkendLinkType = "END"

var enumValues_LinkendLinkType = []interface{}{
	"END",
}

// UnmarshalYAML implements yaml.Unmarshaler.
func (j *LinkendLinkType) UnmarshalYAML(value *yaml.Node) error {
	var v string
	if err := value.Decode(&v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_LinkendLinkType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_LinkendLinkType, v)
	}
	*j = LinkendLinkType(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *LinkendLinkType) UnmarshalJSON(value []byte) error {
	var v string
	if err := json.Unmarshal(value, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_LinkendLinkType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_LinkendLinkType, v)
	}
	*j = LinkendLinkType(v)
	return nil
}

type LinkendTags map[string]interface{}

// UnmarshalYAML implements yaml.Unmarshaler.
func (j *Linkend) UnmarshalYAML(value *yaml.Node) error {
	var raw map[string]interface{}
	if err := value.Decode(&raw); err != nil {
		return err
	}
	if _, ok := raw["linkType"]; raw != nil && !ok {
		return fmt.Errorf("field linkType in Linkend: required")
	}
	type Plain Linkend
	var plain Plain
	if err := value.Decode(&plain); err != nil {
		return err
	}
	*j = Linkend(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *Linkend) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["linkType"]; raw != nil && !ok {
		return fmt.Errorf("field linkType in Linkend: required")
	}
	type Plain Linkend
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = Linkend(plain)
	return nil
}

type Linkpath struct {
	// When consuming a CDEvent, you are consuming a parent event. So, when looking at
	// the 'from' key, this is the parent's parent.
	From LinkpathFrom `json:"from" yaml:"from" mapstructure:"from"`

	// LinkType corresponds to the JSON schema field "linkType".
	LinkType LinkpathLinkType `json:"linkType" yaml:"linkType" mapstructure:"linkType"`

	// Tags corresponds to the JSON schema field "tags".
	Tags LinkpathTags `json:"tags,omitempty" yaml:"tags,omitempty" mapstructure:"tags,omitempty"`
}

// When consuming a CDEvent, you are consuming a parent event. So, when looking at
// the 'from' key, this is the parent's parent.
type LinkpathFrom struct {
	// ContextId corresponds to the JSON schema field "contextId".
	ContextId string `json:"contextId" yaml:"contextId" mapstructure:"contextId"`
}

// UnmarshalYAML implements yaml.Unmarshaler.
func (j *LinkpathFrom) UnmarshalYAML(value *yaml.Node) error {
	var raw map[string]interface{}
	if err := value.Decode(&raw); err != nil {
		return err
	}
	if _, ok := raw["contextId"]; raw != nil && !ok {
		return fmt.Errorf("field contextId in LinkpathFrom: required")
	}
	type Plain LinkpathFrom
	var plain Plain
	if err := value.Decode(&plain); err != nil {
		return err
	}
	if len(plain.ContextId) < 1 {
		return fmt.Errorf("field %s length: must be >= %d", "contextId", 1)
	}
	*j = LinkpathFrom(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *LinkpathFrom) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["contextId"]; raw != nil && !ok {
		return fmt.Errorf("field contextId in LinkpathFrom: required")
	}
	type Plain LinkpathFrom
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	if len(plain.ContextId) < 1 {
		return fmt.Errorf("field %s length: must be >= %d", "contextId", 1)
	}
	*j = LinkpathFrom(plain)
	return nil
}

type LinkpathLinkType string

const LinkpathLinkTypePATH LinkpathLinkType = "PATH"

var enumValues_LinkpathLinkType = []interface{}{
	"PATH",
}

// UnmarshalYAML implements yaml.Unmarshaler.
func (j *LinkpathLinkType) UnmarshalYAML(value *yaml.Node) error {
	var v string
	if err := value.Decode(&v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_LinkpathLinkType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_LinkpathLinkType, v)
	}
	*j = LinkpathLinkType(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *LinkpathLinkType) UnmarshalJSON(value []byte) error {
	var v string
	if err := json.Unmarshal(value, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_LinkpathLinkType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_LinkpathLinkType, v)
	}
	*j = LinkpathLinkType(v)
	return nil
}

type LinkpathTags map[string]interface{}

// UnmarshalJSON implements json.Unmarshaler.
func (j *Linkpath) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["from"]; raw != nil && !ok {
		return fmt.Errorf("field from in Linkpath: required")
	}
	if _, ok := raw["linkType"]; raw != nil && !ok {
		return fmt.Errorf("field linkType in Linkpath: required")
	}
	type Plain Linkpath
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = Linkpath(plain)
	return nil
}

// UnmarshalYAML implements yaml.Unmarshaler.
func (j *Linkpath) UnmarshalYAML(value *yaml.Node) error {
	var raw map[string]interface{}
	if err := value.Decode(&raw); err != nil {
		return err
	}
	if _, ok := raw["from"]; raw != nil && !ok {
		return fmt.Errorf("field from in Linkpath: required")
	}
	if _, ok := raw["linkType"]; raw != nil && !ok {
		return fmt.Errorf("field linkType in Linkpath: required")
	}
	type Plain Linkpath
	var plain Plain
	if err := value.Decode(&plain); err != nil {
		return err
	}
	*j = Linkpath(plain)
	return nil
}

type Linkrelation struct {
	// LinkKind corresponds to the JSON schema field "linkKind".
	LinkKind string `json:"linkKind" yaml:"linkKind" mapstructure:"linkKind"`

	// LinkType corresponds to the JSON schema field "linkType".
	LinkType LinkrelationLinkType `json:"linkType" yaml:"linkType" mapstructure:"linkType"`

	// Tags corresponds to the JSON schema field "tags".
	Tags LinkrelationTags `json:"tags,omitempty" yaml:"tags,omitempty" mapstructure:"tags,omitempty"`

	// Target corresponds to the JSON schema field "target".
	Target LinkrelationTarget `json:"target" yaml:"target" mapstructure:"target"`
}

type LinkrelationLinkType string

const LinkrelationLinkTypeRELATION LinkrelationLinkType = "RELATION"

var enumValues_LinkrelationLinkType = []interface{}{
	"RELATION",
}

// UnmarshalYAML implements yaml.Unmarshaler.
func (j *LinkrelationLinkType) UnmarshalYAML(value *yaml.Node) error {
	var v string
	if err := value.Decode(&v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_LinkrelationLinkType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_LinkrelationLinkType, v)
	}
	*j = LinkrelationLinkType(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *LinkrelationLinkType) UnmarshalJSON(value []byte) error {
	var v string
	if err := json.Unmarshal(value, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_LinkrelationLinkType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_LinkrelationLinkType, v)
	}
	*j = LinkrelationLinkType(v)
	return nil
}

type LinkrelationTags map[string]interface{}

type LinkrelationTarget struct {
	// ContextId corresponds to the JSON schema field "contextId".
	ContextId *string `json:"contextId,omitempty" yaml:"contextId,omitempty" mapstructure:"contextId,omitempty"`
}

// UnmarshalYAML implements yaml.Unmarshaler.
func (j *LinkrelationTarget) UnmarshalYAML(value *yaml.Node) error {
	type Plain LinkrelationTarget
	var plain Plain
	if err := value.Decode(&plain); err != nil {
		return err
	}
	if plain.ContextId != nil && len(*plain.ContextId) < 1 {
		return fmt.Errorf("field %s length: must be >= %d", "contextId", 1)
	}
	*j = LinkrelationTarget(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *LinkrelationTarget) UnmarshalJSON(value []byte) error {
	type Plain LinkrelationTarget
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	if plain.ContextId != nil && len(*plain.ContextId) < 1 {
		return fmt.Errorf("field %s length: must be >= %d", "contextId", 1)
	}
	*j = LinkrelationTarget(plain)
	return nil
}

// UnmarshalYAML implements yaml.Unmarshaler.
func (j *Linkrelation) UnmarshalYAML(value *yaml.Node) error {
	var raw map[string]interface{}
	if err := value.Decode(&raw); err != nil {
		return err
	}
	if _, ok := raw["linkKind"]; raw != nil && !ok {
		return fmt.Errorf("field linkKind in Linkrelation: required")
	}
	if _, ok := raw["linkType"]; raw != nil && !ok {
		return fmt.Errorf("field linkType in Linkrelation: required")
	}
	if _, ok := raw["target"]; raw != nil && !ok {
		return fmt.Errorf("field target in Linkrelation: required")
	}
	type Plain Linkrelation
	var plain Plain
	if err := value.Decode(&plain); err != nil {
		return err
	}
	if len(plain.LinkKind) < 1 {
		return fmt.Errorf("field %s length: must be >= %d", "linkKind", 1)
	}
	*j = Linkrelation(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *Linkrelation) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["linkKind"]; raw != nil && !ok {
		return fmt.Errorf("field linkKind in Linkrelation: required")
	}
	if _, ok := raw["linkType"]; raw != nil && !ok {
		return fmt.Errorf("field linkType in Linkrelation: required")
	}
	if _, ok := raw["target"]; raw != nil && !ok {
		return fmt.Errorf("field target in Linkrelation: required")
	}
	type Plain Linkrelation
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	if len(plain.LinkKind) < 1 {
		return fmt.Errorf("field %s length: must be >= %d", "linkKind", 1)
	}
	*j = Linkrelation(plain)
	return nil
}
