// Code generated by github.com/atombender/go-jsonschema, DO NOT EDIT.

package test

import "encoding/json"
import "errors"
import "fmt"
import yaml "gopkg.in/yaml.v3"
import "reflect"

type TestcaseExpectedPeerName_0 = PeerName

// Represents a peer (i.e., end entity) certificate's name (Subject or SAN).
type TestcaseExpectedPeerName struct {
	// The kind of peer name
	Kind PeerKind `json:"kind" yaml:"kind" mapstructure:"kind"`

	// The peer's name
	Value string `json:"value" yaml:"value" mapstructure:"value"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *PeerKind) UnmarshalJSON(value []byte) error {
	var v string
	if err := json.Unmarshal(value, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_PeerKind {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_PeerKind, v)
	}
	*j = PeerKind(v)
	return nil
}

// UnmarshalYAML implements yaml.Unmarshaler.
func (j *PeerKind) UnmarshalYAML(value *yaml.Node) error {
	var v string
	if err := value.Decode(&v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_PeerKind {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_PeerKind, v)
	}
	*j = PeerKind(v)
	return nil
}

const PeerKindRFC822 PeerKind = "RFC822"
const PeerKindDNS PeerKind = "DNS"
const PeerKindIP PeerKind = "IP"

// Represents a peer (i.e., end entity) certificate's name (Subject or SAN).
type PeerName struct {
	// The kind of peer name
	Kind PeerKind `json:"kind" yaml:"kind" mapstructure:"kind"`

	// The peer's name
	Value string `json:"value" yaml:"value" mapstructure:"value"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *PeerName) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["kind"]; raw != nil && !ok {
		return fmt.Errorf("field kind in PeerName: required")
	}
	if _, ok := raw["value"]; raw != nil && !ok {
		return fmt.Errorf("field value in PeerName: required")
	}
	type Plain PeerName
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = PeerName(plain)
	return nil
}

// UnmarshalYAML implements yaml.Unmarshaler.
func (j *PeerName) UnmarshalYAML(value *yaml.Node) error {
	var raw map[string]interface{}
	if err := value.Decode(&raw); err != nil {
		return err
	}
	if _, ok := raw["kind"]; raw != nil && !ok {
		return fmt.Errorf("field kind in PeerName: required")
	}
	if _, ok := raw["value"]; raw != nil && !ok {
		return fmt.Errorf("field value in PeerName: required")
	}
	type Plain PeerName
	var plain Plain
	if err := value.Decode(&plain); err != nil {
		return err
	}
	*j = PeerName(plain)
	return nil
}

var enumValues_PeerKind = []interface{}{
	"RFC822",
	"DNS",
	"IP",
}

// Represents an individual Limbo testcase.
type Testcase struct {
	// For server (i.e. client-side) validation: the expected peer name, if any
	ExpectedPeerName *TestcaseExpectedPeerName `json:"expected_peer_name" yaml:"expected_peer_name" mapstructure:"expected_peer_name"`

	// For server (i.e. client-side) validation: the expected peer name, if any
	NotExpectedPeerName *TestcaseNotExpectedPeerName `json:"not_expected_peer_name,omitempty" yaml:"not_expected_peer_name,omitempty" mapstructure:"not_expected_peer_name,omitempty"`
}

type PeerKind string

type TestcaseNotExpectedPeerName_0 = PeerName

// UnmarshalYAML implements yaml.Unmarshaler.
func (j *TestcaseExpectedPeerName) UnmarshalYAML(value *yaml.Node) error {
	var raw map[string]interface{}
	if err := value.Decode(&raw); err != nil {
		return err
	}
	var testcaseExpectedPeerName_0 TestcaseExpectedPeerName_0
	var errs []error
	if err := testcaseExpectedPeerName_0.UnmarshalYAML(value); err != nil {
		errs = append(errs, err)
	}
	if len(errs) == 1 {
		return fmt.Errorf("all validators failed: %s", errors.Join(errs...))
	}
	type Plain TestcaseExpectedPeerName
	var plain Plain
	if err := value.Decode(&plain); err != nil {
		return err
	}
	*j = TestcaseExpectedPeerName(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *TestcaseExpectedPeerName) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	var testcaseExpectedPeerName_0 TestcaseExpectedPeerName_0
	var errs []error
	if err := testcaseExpectedPeerName_0.UnmarshalJSON(value); err != nil {
		errs = append(errs, err)
	}
	if len(errs) == 1 {
		return fmt.Errorf("all validators failed: %s", errors.Join(errs...))
	}
	type Plain TestcaseExpectedPeerName
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = TestcaseExpectedPeerName(plain)
	return nil
}

// Represents a peer (i.e., end entity) certificate's name (Subject or SAN).
type TestcaseNotExpectedPeerName struct {
	// The kind of peer name
	Kind PeerKind `json:"kind" yaml:"kind" mapstructure:"kind"`

	// The peer's name
	Value string `json:"value" yaml:"value" mapstructure:"value"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *TestcaseNotExpectedPeerName) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	var testcaseNotExpectedPeerName_0 TestcaseNotExpectedPeerName_0
	var errs []error
	if err := testcaseNotExpectedPeerName_0.UnmarshalJSON(value); err != nil {
		errs = append(errs, err)
	}
	if len(errs) == 1 {
		return fmt.Errorf("all validators failed: %s", errors.Join(errs...))
	}
	type Plain TestcaseNotExpectedPeerName
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = TestcaseNotExpectedPeerName(plain)
	return nil
}

// UnmarshalYAML implements yaml.Unmarshaler.
func (j *TestcaseNotExpectedPeerName) UnmarshalYAML(value *yaml.Node) error {
	var raw map[string]interface{}
	if err := value.Decode(&raw); err != nil {
		return err
	}
	var testcaseNotExpectedPeerName_0 TestcaseNotExpectedPeerName_0
	var errs []error
	if err := testcaseNotExpectedPeerName_0.UnmarshalYAML(value); err != nil {
		errs = append(errs, err)
	}
	if len(errs) == 1 {
		return fmt.Errorf("all validators failed: %s", errors.Join(errs...))
	}
	type Plain TestcaseNotExpectedPeerName
	var plain Plain
	if err := value.Decode(&plain); err != nil {
		return err
	}
	*j = TestcaseNotExpectedPeerName(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *Testcase) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["expected_peer_name"]; raw != nil && !ok {
		return fmt.Errorf("field expected_peer_name in Testcase: required")
	}
	type Plain Testcase
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = Testcase(plain)
	return nil
}

// UnmarshalYAML implements yaml.Unmarshaler.
func (j *Testcase) UnmarshalYAML(value *yaml.Node) error {
	var raw map[string]interface{}
	if err := value.Decode(&raw); err != nil {
		return err
	}
	if _, ok := raw["expected_peer_name"]; raw != nil && !ok {
		return fmt.Errorf("field expected_peer_name in Testcase: required")
	}
	type Plain Testcase
	var plain Plain
	if err := value.Decode(&plain); err != nil {
		return err
	}
	*j = Testcase(plain)
	return nil
}
