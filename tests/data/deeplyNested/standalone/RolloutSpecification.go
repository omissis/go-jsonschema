// Code generated by github.com/atombender/go-jsonschema, DO NOT EDIT.

package test

import "encoding/json"
import "fmt"
import yaml "gopkg.in/yaml.v3"
import "regexp"

// The details of applications to be deployed.
type Applications struct {
	// The list of actions to be performed.
	Actions []string `json:"actions" yaml:"actions" mapstructure:"actions"`

	// The details of the service resources across which the application has to be
	// deployed.
	ApplyAcrossServiceResources ApplyAcrossServiceResources `json:"applyAcrossServiceResources" yaml:"applyAcrossServiceResources" mapstructure:"applyAcrossServiceResources"`

	// The list of the application instance names..
	Names []string `json:"names" yaml:"names" mapstructure:"names"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *Applications) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["actions"]; raw != nil && !ok {
		return fmt.Errorf("field actions in Applications: required")
	}
	if _, ok := raw["applyAcrossServiceResources"]; raw != nil && !ok {
		return fmt.Errorf("field applyAcrossServiceResources in Applications: required")
	}
	if _, ok := raw["names"]; raw != nil && !ok {
		return fmt.Errorf("field names in Applications: required")
	}
	type Plain Applications
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = Applications(plain)
	return nil
}

// UnmarshalYAML implements yaml.Unmarshaler.
func (j *Applications) UnmarshalYAML(value *yaml.Node) error {
	var raw map[string]interface{}
	if err := value.Decode(&raw); err != nil {
		return err
	}
	if _, ok := raw["actions"]; raw != nil && !ok {
		return fmt.Errorf("field actions in Applications: required")
	}
	if _, ok := raw["applyAcrossServiceResources"]; raw != nil && !ok {
		return fmt.Errorf("field applyAcrossServiceResources in Applications: required")
	}
	if _, ok := raw["names"]; raw != nil && !ok {
		return fmt.Errorf("field names in Applications: required")
	}
	type Plain Applications
	var plain Plain
	if err := value.Decode(&plain); err != nil {
		return err
	}
	*j = Applications(plain)
	return nil
}

// The details of the service resources across which the application has to be
// deployed.
type ApplyAcrossServiceResources struct {
	// The service resource definition name.
	DefinitionName string `json:"definitionName" yaml:"definitionName" mapstructure:"definitionName"`

	// Indicates if the cluster has to be deployed before application deployment.
	DeployArmResources *bool `json:"deployArmResources,omitempty" yaml:"deployArmResources,omitempty" mapstructure:"deployArmResources,omitempty"`

	// The list of service resource instance names.
	Names []string `json:"names" yaml:"names" mapstructure:"names"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ApplyAcrossServiceResources) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["definitionName"]; raw != nil && !ok {
		return fmt.Errorf("field definitionName in ApplyAcrossServiceResources: required")
	}
	if _, ok := raw["names"]; raw != nil && !ok {
		return fmt.Errorf("field names in ApplyAcrossServiceResources: required")
	}
	type Plain ApplyAcrossServiceResources
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = ApplyAcrossServiceResources(plain)
	return nil
}

// UnmarshalYAML implements yaml.Unmarshaler.
func (j *ApplyAcrossServiceResources) UnmarshalYAML(value *yaml.Node) error {
	var raw map[string]interface{}
	if err := value.Decode(&raw); err != nil {
		return err
	}
	if _, ok := raw["definitionName"]; raw != nil && !ok {
		return fmt.Errorf("field definitionName in ApplyAcrossServiceResources: required")
	}
	if _, ok := raw["names"]; raw != nil && !ok {
		return fmt.Errorf("field names in ApplyAcrossServiceResources: required")
	}
	type Plain ApplyAcrossServiceResources
	var plain Plain
	if err := value.Decode(&plain); err != nil {
		return err
	}
	*j = ApplyAcrossServiceResources(plain)
	return nil
}

// The location of the build to use for this particular rollout.
type BuildSource struct {
	// The parameters that define how to access and/or prepare the build from this
	// build source.
	Parameters Parameters `json:"parameters" yaml:"parameters" mapstructure:"parameters"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *BuildSource) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["parameters"]; raw != nil && !ok {
		return fmt.Errorf("field parameters in BuildSource: required")
	}
	type Plain BuildSource
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = BuildSource(plain)
	return nil
}

// UnmarshalYAML implements yaml.Unmarshaler.
func (j *BuildSource) UnmarshalYAML(value *yaml.Node) error {
	var raw map[string]interface{}
	if err := value.Decode(&raw); err != nil {
		return err
	}
	if _, ok := raw["parameters"]; raw != nil && !ok {
		return fmt.Errorf("field parameters in BuildSource: required")
	}
	type Plain BuildSource
	var plain Plain
	if err := value.Decode(&plain); err != nil {
		return err
	}
	*j = BuildSource(plain)
	return nil
}

// Option to use configuration specification file directly in rollout.
type Configuration struct {
	// Service scope configuration setting
	ServiceScope *ServiceScope `json:"serviceScope,omitempty" yaml:"serviceScope,omitempty" mapstructure:"serviceScope,omitempty"`
}

// Email Notification definitions
type Email struct {
	// Cc email addresses list separator with ',;'
	Cc *string `json:"cc,omitempty" yaml:"cc,omitempty" mapstructure:"cc,omitempty"`

	// Conditions of when to sending the email, default will send on all start, error,
	// complete events
	Options *Options `json:"options,omitempty" yaml:"options,omitempty" mapstructure:"options,omitempty"`

	// To email addresses list separator with ',;'
	To string `json:"to" yaml:"to" mapstructure:"to"`
}

// UnmarshalYAML implements yaml.Unmarshaler.
func (j *Email) UnmarshalYAML(value *yaml.Node) error {
	var raw map[string]interface{}
	if err := value.Decode(&raw); err != nil {
		return err
	}
	if _, ok := raw["to"]; raw != nil && !ok {
		return fmt.Errorf("field to in Email: required")
	}
	type Plain Email
	var plain Plain
	if err := value.Decode(&plain); err != nil {
		return err
	}
	*j = Email(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *Email) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["to"]; raw != nil && !ok {
		return fmt.Errorf("field to in Email: required")
	}
	type Plain Email
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = Email(plain)
	return nil
}

// Incident notification definitions
type Incident struct {
	// Conditions of when to create incidents, default will send on every error
	Options *IncidentOptions `json:"options,omitempty" yaml:"options,omitempty" mapstructure:"options,omitempty"`

	// The incident properties
	Properties Properties `json:"properties" yaml:"properties" mapstructure:"properties"`

	// The incident provider type
	ProviderType string `json:"providerType" yaml:"providerType" mapstructure:"providerType"`
}

// Conditions of when to create incidents, default will send on every error
type IncidentOptions struct {
	// When corresponds to the JSON schema field "when".
	When []string `json:"when,omitempty" yaml:"when,omitempty" mapstructure:"when,omitempty"`
}

// UnmarshalYAML implements yaml.Unmarshaler.
func (j *Incident) UnmarshalYAML(value *yaml.Node) error {
	var raw map[string]interface{}
	if err := value.Decode(&raw); err != nil {
		return err
	}
	if _, ok := raw["properties"]; raw != nil && !ok {
		return fmt.Errorf("field properties in Incident: required")
	}
	if _, ok := raw["providerType"]; raw != nil && !ok {
		return fmt.Errorf("field providerType in Incident: required")
	}
	type Plain Incident
	var plain Plain
	if err := value.Decode(&plain); err != nil {
		return err
	}
	*j = Incident(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *Incident) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["properties"]; raw != nil && !ok {
		return fmt.Errorf("field properties in Incident: required")
	}
	if _, ok := raw["providerType"]; raw != nil && !ok {
		return fmt.Errorf("field providerType in Incident: required")
	}
	type Plain Incident
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = Incident(plain)
	return nil
}

// Notification definitions
type Notification struct {
	// Email Notification definitions
	Email *Email `json:"email,omitempty" yaml:"email,omitempty" mapstructure:"email,omitempty"`

	// Incident notification definitions
	Incident *Incident `json:"incident,omitempty" yaml:"incident,omitempty" mapstructure:"incident,omitempty"`
}

// Conditions of when to sending the email, default will send on all start, error,
// complete events
type Options struct {
	// 'All': All rollout information, default behavior, SummaryOnly': Only has
	// summary table, no resource deployment details, Compact': Only show rows of
	// failed resource operations.
	Verbosity *string `json:"verbosity,omitempty" yaml:"verbosity,omitempty" mapstructure:"verbosity,omitempty"`

	// When corresponds to the JSON schema field "when".
	When []string `json:"when,omitempty" yaml:"when,omitempty" mapstructure:"when,omitempty"`
}

// UnmarshalYAML implements yaml.Unmarshaler.
func (j *Options) UnmarshalYAML(value *yaml.Node) error {
	type Plain Options
	var plain Plain
	if err := value.Decode(&plain); err != nil {
		return err
	}
	if plain.Verbosity != nil {
		if matched, _ := regexp.MatchString(`(?i)(^All$|^SummaryOnly$|^Compact$)`, string(*plain.Verbosity)); !matched {
			return fmt.Errorf("field %s pattern match: must match %s", "Verbosity", `(?i)(^All$|^SummaryOnly$|^Compact$)`)
		}
	}
	*j = Options(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *Options) UnmarshalJSON(value []byte) error {
	type Plain Options
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	if plain.Verbosity != nil {
		if matched, _ := regexp.MatchString(`(?i)(^All$|^SummaryOnly$|^Compact$)`, string(*plain.Verbosity)); !matched {
			return fmt.Errorf("field %s pattern match: must match %s", "Verbosity", `(?i)(^All$|^SummaryOnly$|^Compact$)`)
		}
	}
	*j = Options(plain)
	return nil
}

// An individual deployment step in the rollout of an Azure service.
type OrchestratedStep struct {
	// The actions that must take place as part of this step. The actions will be
	// executed in the order that they are declared. The action names must be unique.
	// If this is an Extension action, the name of the extension must exist in the
	// 'Extensions' block in  RolloutParameters.
	Actions []string `json:"actions,omitempty" yaml:"actions,omitempty" mapstructure:"actions,omitempty"`

	// The details of applications to be deployed.
	Applications *Applications `json:"applications,omitempty" yaml:"applications,omitempty" mapstructure:"applications,omitempty"`

	// The names of the rollout steps that must be executed prior to the current step
	// being executed.
	DependsOn []string `json:"dependsOn,omitempty" yaml:"dependsOn,omitempty" mapstructure:"dependsOn,omitempty"`

	// The name of the rollout step.
	Name string `json:"name" yaml:"name" mapstructure:"name"`

	// The unique identifier of the target that is to be updated.
	TargetName *string `json:"targetName,omitempty" yaml:"targetName,omitempty" mapstructure:"targetName,omitempty"`

	// The type of the intended target of this rollout.
	TargetType string `json:"targetType" yaml:"targetType" mapstructure:"targetType"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *OrchestratedStep) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["name"]; raw != nil && !ok {
		return fmt.Errorf("field name in OrchestratedStep: required")
	}
	if _, ok := raw["targetType"]; raw != nil && !ok {
		return fmt.Errorf("field targetType in OrchestratedStep: required")
	}
	type Plain OrchestratedStep
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	if len(plain.Name) < 1 {
		return fmt.Errorf("field %s length: must be >= %d", "name", 1)
	}
	if plain.TargetName != nil && len(*plain.TargetName) < 1 {
		return fmt.Errorf("field %s length: must be >= %d", "targetName", 1)
	}
	if matched, _ := regexp.MatchString(`(?i)(^ServiceResourceGroup$|^ServiceResource$|^Application$)`, string(plain.TargetType)); !matched {
		return fmt.Errorf("field %s pattern match: must match %s", "TargetType", `(?i)(^ServiceResourceGroup$|^ServiceResource$|^Application$)`)
	}
	*j = OrchestratedStep(plain)
	return nil
}

// UnmarshalYAML implements yaml.Unmarshaler.
func (j *OrchestratedStep) UnmarshalYAML(value *yaml.Node) error {
	var raw map[string]interface{}
	if err := value.Decode(&raw); err != nil {
		return err
	}
	if _, ok := raw["name"]; raw != nil && !ok {
		return fmt.Errorf("field name in OrchestratedStep: required")
	}
	if _, ok := raw["targetType"]; raw != nil && !ok {
		return fmt.Errorf("field targetType in OrchestratedStep: required")
	}
	type Plain OrchestratedStep
	var plain Plain
	if err := value.Decode(&plain); err != nil {
		return err
	}
	if len(plain.Name) < 1 {
		return fmt.Errorf("field %s length: must be >= %d", "name", 1)
	}
	if plain.TargetName != nil && len(*plain.TargetName) < 1 {
		return fmt.Errorf("field %s length: must be >= %d", "targetName", 1)
	}
	if matched, _ := regexp.MatchString(`(?i)(^ServiceResourceGroup$|^ServiceResource$|^Application$)`, string(plain.TargetType)); !matched {
		return fmt.Errorf("field %s pattern match: must match %s", "TargetType", `(?i)(^ServiceResourceGroup$|^ServiceResource$|^Application$)`)
	}
	*j = OrchestratedStep(plain)
	return nil
}

// The parameters that define how to access and/or prepare the build from this
// build source.
type Parameters struct {
	// The path relative to the Service Group Root which points to the file whose
	// contents represent the version of the build being deployed.
	VersionFile string `json:"versionFile" yaml:"versionFile" mapstructure:"versionFile"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *Parameters) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["versionFile"]; raw != nil && !ok {
		return fmt.Errorf("field versionFile in Parameters: required")
	}
	type Plain Parameters
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = Parameters(plain)
	return nil
}

// UnmarshalYAML implements yaml.Unmarshaler.
func (j *Parameters) UnmarshalYAML(value *yaml.Node) error {
	var raw map[string]interface{}
	if err := value.Decode(&raw); err != nil {
		return err
	}
	if _, ok := raw["versionFile"]; raw != nil && !ok {
		return fmt.Errorf("field versionFile in Parameters: required")
	}
	type Plain Parameters
	var plain Plain
	if err := value.Decode(&plain); err != nil {
		return err
	}
	*j = Parameters(plain)
	return nil
}

// The incident properties
type Properties struct {
	// The connector Id for ICM
	ConnectorId string `json:"connectorId" yaml:"connectorId" mapstructure:"connectorId"`

	// The incident correlation type.
	CorrelateBy *string `json:"correlateBy,omitempty" yaml:"correlateBy,omitempty" mapstructure:"correlateBy,omitempty"`

	// The environment of the incidents raising location.
	Environment *string `json:"environment,omitempty" yaml:"environment,omitempty" mapstructure:"environment,omitempty"`

	// The routing Id for ICM
	RoutingId string `json:"routingId" yaml:"routingId" mapstructure:"routingId"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *Properties) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["connectorId"]; raw != nil && !ok {
		return fmt.Errorf("field connectorId in Properties: required")
	}
	if _, ok := raw["routingId"]; raw != nil && !ok {
		return fmt.Errorf("field routingId in Properties: required")
	}
	type Plain Properties
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	if plain.CorrelateBy != nil {
		if matched, _ := regexp.MatchString(`(?i)(^rollout$)`, string(*plain.CorrelateBy)); !matched {
			return fmt.Errorf("field %s pattern match: must match %s", "CorrelateBy", `(?i)(^rollout$)`)
		}
	}
	if plain.Environment != nil {
		if matched, _ := regexp.MatchString(`(?i)(^Dogfood$|^Int$|^Ppe$|^Prod$|^Staging$|^Test$)`, string(*plain.Environment)); !matched {
			return fmt.Errorf("field %s pattern match: must match %s", "Environment", `(?i)(^Dogfood$|^Int$|^Ppe$|^Prod$|^Staging$|^Test$)`)
		}
	}
	*j = Properties(plain)
	return nil
}

// UnmarshalYAML implements yaml.Unmarshaler.
func (j *Properties) UnmarshalYAML(value *yaml.Node) error {
	var raw map[string]interface{}
	if err := value.Decode(&raw); err != nil {
		return err
	}
	if _, ok := raw["connectorId"]; raw != nil && !ok {
		return fmt.Errorf("field connectorId in Properties: required")
	}
	if _, ok := raw["routingId"]; raw != nil && !ok {
		return fmt.Errorf("field routingId in Properties: required")
	}
	type Plain Properties
	var plain Plain
	if err := value.Decode(&plain); err != nil {
		return err
	}
	if plain.CorrelateBy != nil {
		if matched, _ := regexp.MatchString(`(?i)(^rollout$)`, string(*plain.CorrelateBy)); !matched {
			return fmt.Errorf("field %s pattern match: must match %s", "CorrelateBy", `(?i)(^rollout$)`)
		}
	}
	if plain.Environment != nil {
		if matched, _ := regexp.MatchString(`(?i)(^Dogfood$|^Int$|^Ppe$|^Prod$|^Staging$|^Test$)`, string(*plain.Environment)); !matched {
			return fmt.Errorf("field %s pattern match: must match %s", "Environment", `(?i)(^Dogfood$|^Int$|^Ppe$|^Prod$|^Staging$|^Test$)`)
		}
	}
	*j = Properties(plain)
	return nil
}

// The metadata associated with this particular rollout.
type RolloutMetadata struct {
	// The location of the build to use for this particular rollout.
	BuildSource BuildSource `json:"buildSource" yaml:"buildSource" mapstructure:"buildSource"`

	// Option to use configuration specification file directly in rollout.
	Configuration *Configuration `json:"configuration,omitempty" yaml:"configuration,omitempty" mapstructure:"configuration,omitempty"`

	// The user-specified name of this particular rollout.
	Name string `json:"name" yaml:"name" mapstructure:"name"`

	// Notification definitions
	Notification *Notification `json:"notification,omitempty" yaml:"notification,omitempty" mapstructure:"notification,omitempty"`

	// The path relative to the Service Group Root that points to the parameter
	// replacements file.
	ParameterReplacementsPath *string `json:"parameterReplacementsPath,omitempty" yaml:"parameterReplacementsPath,omitempty" mapstructure:"parameterReplacementsPath,omitempty"`

	// List of rollout policy references to use for the rollout.
	RolloutPolicyReferences []RolloutPolicyReference `json:"rolloutPolicyReferences,omitempty" yaml:"rolloutPolicyReferences,omitempty" mapstructure:"rolloutPolicyReferences,omitempty"`

	// The scope of this particular rollout.
	RolloutType string `json:"rolloutType" yaml:"rolloutType" mapstructure:"rolloutType"`

	// The path relative to the Service Group Root that points to the service model of
	// the service that is being updated as part of this rollout.
	ServiceModelPath string `json:"serviceModelPath" yaml:"serviceModelPath" mapstructure:"serviceModelPath"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *RolloutMetadata) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["buildSource"]; raw != nil && !ok {
		return fmt.Errorf("field buildSource in RolloutMetadata: required")
	}
	if _, ok := raw["name"]; raw != nil && !ok {
		return fmt.Errorf("field name in RolloutMetadata: required")
	}
	if _, ok := raw["rolloutType"]; raw != nil && !ok {
		return fmt.Errorf("field rolloutType in RolloutMetadata: required")
	}
	if _, ok := raw["serviceModelPath"]; raw != nil && !ok {
		return fmt.Errorf("field serviceModelPath in RolloutMetadata: required")
	}
	type Plain RolloutMetadata
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	if len(plain.Name) < 1 {
		return fmt.Errorf("field %s length: must be >= %d", "name", 1)
	}
	if matched, _ := regexp.MatchString(`(?i)(^Major$|^Minor$|^Hotfix$)`, string(plain.RolloutType)); !matched {
		return fmt.Errorf("field %s pattern match: must match %s", "RolloutType", `(?i)(^Major$|^Minor$|^Hotfix$)`)
	}
	*j = RolloutMetadata(plain)
	return nil
}

// UnmarshalYAML implements yaml.Unmarshaler.
func (j *RolloutMetadata) UnmarshalYAML(value *yaml.Node) error {
	var raw map[string]interface{}
	if err := value.Decode(&raw); err != nil {
		return err
	}
	if _, ok := raw["buildSource"]; raw != nil && !ok {
		return fmt.Errorf("field buildSource in RolloutMetadata: required")
	}
	if _, ok := raw["name"]; raw != nil && !ok {
		return fmt.Errorf("field name in RolloutMetadata: required")
	}
	if _, ok := raw["rolloutType"]; raw != nil && !ok {
		return fmt.Errorf("field rolloutType in RolloutMetadata: required")
	}
	if _, ok := raw["serviceModelPath"]; raw != nil && !ok {
		return fmt.Errorf("field serviceModelPath in RolloutMetadata: required")
	}
	type Plain RolloutMetadata
	var plain Plain
	if err := value.Decode(&plain); err != nil {
		return err
	}
	if len(plain.Name) < 1 {
		return fmt.Errorf("field %s length: must be >= %d", "name", 1)
	}
	if matched, _ := regexp.MatchString(`(?i)(^Major$|^Minor$|^Hotfix$)`, string(plain.RolloutType)); !matched {
		return fmt.Errorf("field %s pattern match: must match %s", "RolloutType", `(?i)(^Major$|^Minor$|^Hotfix$)`)
	}
	*j = RolloutMetadata(plain)
	return nil
}

// Policy reference details.
type RolloutPolicyReference struct {
	// The name of the policy.
	Name string `json:"name" yaml:"name" mapstructure:"name"`

	// The version of the policy to use. Specify '*' to use the latest registered
	// version of the policy.
	Version string `json:"version" yaml:"version" mapstructure:"version"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *RolloutPolicyReference) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["name"]; raw != nil && !ok {
		return fmt.Errorf("field name in RolloutPolicyReference: required")
	}
	if _, ok := raw["version"]; raw != nil && !ok {
		return fmt.Errorf("field version in RolloutPolicyReference: required")
	}
	type Plain RolloutPolicyReference
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = RolloutPolicyReference(plain)
	return nil
}

// UnmarshalYAML implements yaml.Unmarshaler.
func (j *RolloutPolicyReference) UnmarshalYAML(value *yaml.Node) error {
	var raw map[string]interface{}
	if err := value.Decode(&raw); err != nil {
		return err
	}
	if _, ok := raw["name"]; raw != nil && !ok {
		return fmt.Errorf("field name in RolloutPolicyReference: required")
	}
	if _, ok := raw["version"]; raw != nil && !ok {
		return fmt.Errorf("field version in RolloutPolicyReference: required")
	}
	type Plain RolloutPolicyReference
	var plain Plain
	if err := value.Decode(&plain); err != nil {
		return err
	}
	*j = RolloutPolicyReference(plain)
	return nil
}

// A document that declares what actions are to be taken as part of an update to an
// Azure Service.
type RolloutSpecification struct {
	// The version of the schema that a document conforms to.
	ContentVersion string `json:"contentVersion" yaml:"contentVersion" mapstructure:"contentVersion"`

	// The exact sequence of steps that must be executed as part of this rollout.
	OrchestratedSteps []OrchestratedStep `json:"orchestratedSteps" yaml:"orchestratedSteps" mapstructure:"orchestratedSteps"`

	// The metadata associated with this particular rollout.
	RolloutMetadata RolloutMetadata `json:"rolloutMetadata" yaml:"rolloutMetadata" mapstructure:"rolloutMetadata"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *RolloutSpecification) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["contentVersion"]; raw != nil && !ok {
		return fmt.Errorf("field contentVersion in RolloutSpecification: required")
	}
	if _, ok := raw["orchestratedSteps"]; raw != nil && !ok {
		return fmt.Errorf("field orchestratedSteps in RolloutSpecification: required")
	}
	if _, ok := raw["rolloutMetadata"]; raw != nil && !ok {
		return fmt.Errorf("field rolloutMetadata in RolloutSpecification: required")
	}
	type Plain RolloutSpecification
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	if matched, _ := regexp.MatchString(`^([0-9]+\.)?([0-9]+\.)?([0-9]+\.)?([0-9]+){1}$`, string(plain.ContentVersion)); !matched {
		return fmt.Errorf("field %s pattern match: must match %s", "ContentVersion", `^([0-9]+\.)?([0-9]+\.)?([0-9]+\.)?([0-9]+){1}$`)
	}
	*j = RolloutSpecification(plain)
	return nil
}

// UnmarshalYAML implements yaml.Unmarshaler.
func (j *RolloutSpecification) UnmarshalYAML(value *yaml.Node) error {
	var raw map[string]interface{}
	if err := value.Decode(&raw); err != nil {
		return err
	}
	if _, ok := raw["contentVersion"]; raw != nil && !ok {
		return fmt.Errorf("field contentVersion in RolloutSpecification: required")
	}
	if _, ok := raw["orchestratedSteps"]; raw != nil && !ok {
		return fmt.Errorf("field orchestratedSteps in RolloutSpecification: required")
	}
	if _, ok := raw["rolloutMetadata"]; raw != nil && !ok {
		return fmt.Errorf("field rolloutMetadata in RolloutSpecification: required")
	}
	type Plain RolloutSpecification
	var plain Plain
	if err := value.Decode(&plain); err != nil {
		return err
	}
	if matched, _ := regexp.MatchString(`^([0-9]+\.)?([0-9]+\.)?([0-9]+\.)?([0-9]+){1}$`, string(plain.ContentVersion)); !matched {
		return fmt.Errorf("field %s pattern match: must match %s", "ContentVersion", `^([0-9]+\.)?([0-9]+\.)?([0-9]+\.)?([0-9]+){1}$`)
	}
	*j = RolloutSpecification(plain)
	return nil
}

// Service scope configuration setting
type ServiceScope struct {
	// The path relative to the Service Group Root that points to the service scope
	// configuration specification.
	SpecPath *string `json:"specPath,omitempty" yaml:"specPath,omitempty" mapstructure:"specPath,omitempty"`
}
